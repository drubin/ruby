=begin
#Kubernetes

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: v1.13.4

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.2.3

=end

require 'date'

module Kubernetes
  # JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
  class V1beta1JSONSchemaProps
    attr_accessor :ref

    attr_accessor :schema

    # JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property.
    attr_accessor :additional_items

    # JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property.
    attr_accessor :additional_properties

    attr_accessor :all_of

    attr_accessor :any_of

    # JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
    attr_accessor :default

    attr_accessor :definitions

    attr_accessor :dependencies

    attr_accessor :description

    attr_accessor :enum

    # JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
    attr_accessor :example

    attr_accessor :exclusive_maximum

    attr_accessor :exclusive_minimum

    attr_accessor :external_docs

    attr_accessor :format

    attr_accessor :id

    # JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes.
    attr_accessor :items

    attr_accessor :max_items

    attr_accessor :max_length

    attr_accessor :max_properties

    attr_accessor :maximum

    attr_accessor :min_items

    attr_accessor :min_length

    attr_accessor :min_properties

    attr_accessor :minimum

    attr_accessor :multiple_of

    attr_accessor :_not

    attr_accessor :one_of

    attr_accessor :pattern

    attr_accessor :pattern_properties

    attr_accessor :properties

    attr_accessor :required

    attr_accessor :title

    attr_accessor :type

    attr_accessor :unique_items


    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'ref' => :'$ref',
        :'schema' => :'$schema',
        :'additional_items' => :'additionalItems',
        :'additional_properties' => :'additionalProperties',
        :'all_of' => :'allOf',
        :'any_of' => :'anyOf',
        :'default' => :'default',
        :'definitions' => :'definitions',
        :'dependencies' => :'dependencies',
        :'description' => :'description',
        :'enum' => :'enum',
        :'example' => :'example',
        :'exclusive_maximum' => :'exclusiveMaximum',
        :'exclusive_minimum' => :'exclusiveMinimum',
        :'external_docs' => :'externalDocs',
        :'format' => :'format',
        :'id' => :'id',
        :'items' => :'items',
        :'max_items' => :'maxItems',
        :'max_length' => :'maxLength',
        :'max_properties' => :'maxProperties',
        :'maximum' => :'maximum',
        :'min_items' => :'minItems',
        :'min_length' => :'minLength',
        :'min_properties' => :'minProperties',
        :'minimum' => :'minimum',
        :'multiple_of' => :'multipleOf',
        :'_not' => :'not',
        :'one_of' => :'oneOf',
        :'pattern' => :'pattern',
        :'pattern_properties' => :'patternProperties',
        :'properties' => :'properties',
        :'required' => :'required',
        :'title' => :'title',
        :'type' => :'type',
        :'unique_items' => :'uniqueItems'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'ref' => :'String',
        :'schema' => :'String',
        :'additional_items' => :'Object',
        :'additional_properties' => :'Object',
        :'all_of' => :'Array<V1beta1JSONSchemaProps>',
        :'any_of' => :'Array<V1beta1JSONSchemaProps>',
        :'default' => :'Object',
        :'definitions' => :'Hash<String, V1beta1JSONSchemaProps>',
        :'dependencies' => :'Hash<String, Object>',
        :'description' => :'String',
        :'enum' => :'Array<Object>',
        :'example' => :'Object',
        :'exclusive_maximum' => :'BOOLEAN',
        :'exclusive_minimum' => :'BOOLEAN',
        :'external_docs' => :'V1beta1ExternalDocumentation',
        :'format' => :'String',
        :'id' => :'String',
        :'items' => :'Object',
        :'max_items' => :'Integer',
        :'max_length' => :'Integer',
        :'max_properties' => :'Integer',
        :'maximum' => :'Float',
        :'min_items' => :'Integer',
        :'min_length' => :'Integer',
        :'min_properties' => :'Integer',
        :'minimum' => :'Float',
        :'multiple_of' => :'Float',
        :'_not' => :'V1beta1JSONSchemaProps',
        :'one_of' => :'Array<V1beta1JSONSchemaProps>',
        :'pattern' => :'String',
        :'pattern_properties' => :'Hash<String, V1beta1JSONSchemaProps>',
        :'properties' => :'Hash<String, V1beta1JSONSchemaProps>',
        :'required' => :'Array<String>',
        :'title' => :'String',
        :'type' => :'String',
        :'unique_items' => :'BOOLEAN'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'$ref')
        self.ref = attributes[:'$ref']
      end

      if attributes.has_key?(:'$schema')
        self.schema = attributes[:'$schema']
      end

      if attributes.has_key?(:'additionalItems')
        self.additional_items = attributes[:'additionalItems']
      end

      if attributes.has_key?(:'additionalProperties')
        self.additional_properties = attributes[:'additionalProperties']
      end

      if attributes.has_key?(:'allOf')
        if (value = attributes[:'allOf']).is_a?(Array)
          self.all_of = value
        end
      end

      if attributes.has_key?(:'anyOf')
        if (value = attributes[:'anyOf']).is_a?(Array)
          self.any_of = value
        end
      end

      if attributes.has_key?(:'default')
        self.default = attributes[:'default']
      end

      if attributes.has_key?(:'definitions')
        if (value = attributes[:'definitions']).is_a?(Array)
          self.definitions = value
        end
      end

      if attributes.has_key?(:'dependencies')
        if (value = attributes[:'dependencies']).is_a?(Array)
          self.dependencies = value
        end
      end

      if attributes.has_key?(:'description')
        self.description = attributes[:'description']
      end

      if attributes.has_key?(:'enum')
        if (value = attributes[:'enum']).is_a?(Array)
          self.enum = value
        end
      end

      if attributes.has_key?(:'example')
        self.example = attributes[:'example']
      end

      if attributes.has_key?(:'exclusiveMaximum')
        self.exclusive_maximum = attributes[:'exclusiveMaximum']
      end

      if attributes.has_key?(:'exclusiveMinimum')
        self.exclusive_minimum = attributes[:'exclusiveMinimum']
      end

      if attributes.has_key?(:'externalDocs')
        self.external_docs = attributes[:'externalDocs']
      end

      if attributes.has_key?(:'format')
        self.format = attributes[:'format']
      end

      if attributes.has_key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.has_key?(:'items')
        self.items = attributes[:'items']
      end

      if attributes.has_key?(:'maxItems')
        self.max_items = attributes[:'maxItems']
      end

      if attributes.has_key?(:'maxLength')
        self.max_length = attributes[:'maxLength']
      end

      if attributes.has_key?(:'maxProperties')
        self.max_properties = attributes[:'maxProperties']
      end

      if attributes.has_key?(:'maximum')
        self.maximum = attributes[:'maximum']
      end

      if attributes.has_key?(:'minItems')
        self.min_items = attributes[:'minItems']
      end

      if attributes.has_key?(:'minLength')
        self.min_length = attributes[:'minLength']
      end

      if attributes.has_key?(:'minProperties')
        self.min_properties = attributes[:'minProperties']
      end

      if attributes.has_key?(:'minimum')
        self.minimum = attributes[:'minimum']
      end

      if attributes.has_key?(:'multipleOf')
        self.multiple_of = attributes[:'multipleOf']
      end

      if attributes.has_key?(:'not')
        self._not = attributes[:'not']
      end

      if attributes.has_key?(:'oneOf')
        if (value = attributes[:'oneOf']).is_a?(Array)
          self.one_of = value
        end
      end

      if attributes.has_key?(:'pattern')
        self.pattern = attributes[:'pattern']
      end

      if attributes.has_key?(:'patternProperties')
        if (value = attributes[:'patternProperties']).is_a?(Array)
          self.pattern_properties = value
        end
      end

      if attributes.has_key?(:'properties')
        if (value = attributes[:'properties']).is_a?(Array)
          self.properties = value
        end
      end

      if attributes.has_key?(:'required')
        if (value = attributes[:'required']).is_a?(Array)
          self.required = value
        end
      end

      if attributes.has_key?(:'title')
        self.title = attributes[:'title']
      end

      if attributes.has_key?(:'type')
        self.type = attributes[:'type']
      end

      if attributes.has_key?(:'uniqueItems')
        self.unique_items = attributes[:'uniqueItems']
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properies with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          ref == o.ref &&
          schema == o.schema &&
          additional_items == o.additional_items &&
          additional_properties == o.additional_properties &&
          all_of == o.all_of &&
          any_of == o.any_of &&
          default == o.default &&
          definitions == o.definitions &&
          dependencies == o.dependencies &&
          description == o.description &&
          enum == o.enum &&
          example == o.example &&
          exclusive_maximum == o.exclusive_maximum &&
          exclusive_minimum == o.exclusive_minimum &&
          external_docs == o.external_docs &&
          format == o.format &&
          id == o.id &&
          items == o.items &&
          max_items == o.max_items &&
          max_length == o.max_length &&
          max_properties == o.max_properties &&
          maximum == o.maximum &&
          min_items == o.min_items &&
          min_length == o.min_length &&
          min_properties == o.min_properties &&
          minimum == o.minimum &&
          multiple_of == o.multiple_of &&
          _not == o._not &&
          one_of == o.one_of &&
          pattern == o.pattern &&
          pattern_properties == o.pattern_properties &&
          properties == o.properties &&
          required == o.required &&
          title == o.title &&
          type == o.type &&
          unique_items == o.unique_items
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [ref, schema, additional_items, additional_properties, all_of, any_of, default, definitions, dependencies, description, enum, example, exclusive_maximum, exclusive_minimum, external_docs, format, id, items, max_items, max_length, max_properties, maximum, min_items, min_length, min_properties, minimum, multiple_of, _not, one_of, pattern, pattern_properties, properties, required, title, type, unique_items].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = Kubernetes.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
